deepdive {

  db.default {
    driver   : "org.postgresql.Driver"
    url      : "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user     : ${PGUSER}
    password : ${PGPASSWORD}
    dbname   : ${DBNAME}
    host     : ${PGHOST}
    port     : ${PGPORT}
  }

  # Put your variables here
  schema.variables {
    true_grades.true_grade:Categorical(8)
  }

  # Put your extractors here
  extraction.extractors {
    # Extractor 1: Clean output tables of all extractors
    ext_clear_table {
      style: "sql_extractor"
      sql: """
        DELETE FROM true_grades;
        DELETE FROM grade_mentions;
        DELETE FROM grade_candidates;
        DELETE FROM grade_features;
        """
    }

    # Extractor 2: extract grade mentions:
    ext_grade {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  patient_id,
                sentence_id,
                array_to_string(words, '~^~'),
                array_to_string(lemma, '~^~')
          FROM  sentences"""

      # output of extractor will be written to this table:
      output_relation: "grade_mentions"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_grade.py"

      dependencies: ["ext_clear_table"]
    }
   
    # Extractor 3: extract true grade features:
    ext_true_grade {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  patient_id
        FROM    grade_mentions"""
      # output of extractor will be written to this table:
      output_relation: "true_grades"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_true_grade.py"

      #dependencies: ["ext_clear_table"]
      dependencies: ["ext_grade"]
    }

    # Extractor 3: manual (weight) extract fine-tune grade candidate:
    ext_grade_finetune {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  patient_id,
                string_agg(mention_id, E'~^~') AS mention,
                string_agg(lemma_phrase, E'~^~') AS lemma
          FROM  grade_mentions
          GROUP BY patient_id
          ORDER BY patient_id"""
      # output of extractor will be written to this table:
      output_relation: "grade_candidates"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_grade_finetune.py"
      
      dependencies: ["ext_grade"]
    }

    # Extractor 4: extract fine-tune grade features:
    ext_grade_features {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  grade_mentions.patient_id,
                string_agg(mention_id, E'~^~') AS mention,
                string_agg(lemma_phrase, E'~^~') AS lemma,
                true_grade
          FROM  grade_mentions, true_grades
          WHERE grade_mentions.patient_id = true_grades.patient_id
          GROUP BY grade_mentions.patient_id, true_grades.true_grade
          ORDER BY grade_mentions.patient_id"""
      # output of extractor will be written to this table:
      output_relation: "grade_features"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_grade_features.py"
      
      dependencies: ["ext_true_grade"]
    }
    
    # Extractor 4: extract fine-tune grade features:
    #ext_grade_features {
    #  # The style of the extractor
    #  style: "tsv_extractor"
    #  # An input to the extractor is a row (tuple) of the following query:
    #  input: """
    #    SELECT  patient_id,
    #            string_agg(mention_id, E'~^~') AS mention,
    #            string_agg(lemma_phrase, E'~^~') AS lemma
    #      FROM  grade_mentions
    #      GROUP BY patient_id
    #      ORDER BY patient_id"""
    #  # output of extractor will be written to this table:
    #  output_relation: "grade_features"

      # This user-defined function will be performed on each row (tuple) of input query:
    #  udf: ${APP_HOME}"/udf/ext_grade_features.py"
      
    #  dependencies: ["ext_grade"]
    #}

    # Extractor 3: extract mention relation candidates
    # ext_has_1_candidates {
    #   # The style of the extractor
    #   style: tsv_extractor
    #   # Each input (p1, p2) is a pair of mentions
    #   input: """
    #     SELECT  sentences.sentence_id,
    #             p1.mention_id AS p1_mention_id,
    #             p1.text       AS p1_text,
    #             p2.mention_id AS p2_mention_id,
    #             p2.text       AS p2_text
    #      FROM   people_mentions p1,
    #             people_mentions p2,
    #             sentences
    #     WHERE   p1.sentence_id = p2.sentence_id
    #       AND   p1.sentence_id = sentences.sentence_id
    #       AND   p1.mention_id != p2.mention_id;
    #       """
    #   output_relation : "has_spouse"
    #   udf             : ${APP_HOME}"/udf/ext_has_spouse.py"

    #   # Run this extractor after "ext_people"
    #   dependencies    : ["ext_people"]
    # }

     # Extractor 4: extract features for relation candidates
     #ext_has_spouse_features {
     #  style: "tsv_extractor"
     #  input: """
     #    SELECT  array_to_string(words, '~^~'),
     #            has_spouse.relation_id,
     #            p1.start_position  AS  p1_start,
     #            p1.length          AS  p1_length,
     #            p2.start_position  AS  p2_start,
     #            p2.length          AS  p2_length
     #      FROM  has_spouse,
     #            people_mentions p1,
     #            people_mentions p2,
     #            sentences
     #     WHERE  has_spouse.person1_id = p1.mention_id
     #       AND  has_spouse.person2_id = p2.mention_id
     #       AND  has_spouse.sentence_id = sentences.sentence_id;
     #       """
     #  output_relation : "has_spouse_features"
     #  udf             : ${APP_HOME}"/udf/ext_has_spouse_features.py"
     #  dependencies    : ["ext_has_spouse_candidates"]
     #}

  }

  # Put your inference rules here
  inference.factors {

    # # A simple logistic regression rule
    # f_has_spouse_features {

    #   # input to the inference rule is all the has_spouse candidate relations,
    #   #   as well as the features connected to them:
    #   input_query: """
    #     SELECT has_spouse.id      AS "has_spouse.id",
    #            has_spouse.is_true AS "has_spouse.is_true",
    #            feature
    #     FROM has_spouse,
    #          has_spouse_features
    #     WHERE has_spouse_features.relation_id = has_spouse.relation_id
    #     """

    #   # Factor function:
    #   function : "IsTrue(has_spouse.is_true)"

    #   # Weight of the factor is decided by the value of "feature" column in input query
    #   weight   : "?(feature)"
    # }
    
    #feature_factor {
    #  input_query: """
    #    SELECT  true_grades.id    AS "true_grades.id",
    #            true_grades.true_grade AS "trude_grades.true_grade",
    #            grade_features.feature
    #    FROM    true_grades, 
    #            grade_features
    #    WHERE   true_grades.patient_id = grade_features.patient_id
    #    """

    #  # Factor function:
    #  function: "Multinomial(true_grades.true_grade)"
    #  weight: "?(feature)"
    #}
  }

  # Specify a holdout fraction
  calibration.holdout_fraction: 0.25

  # calibration.holdout_query:"""
  #   DROP TABLE IF EXISTS holdout_sentence_ids CASCADE;

  #   CREATE TABLE holdout_sentence_ids AS
  #   SELECT sentence_id FROM sentences WHERE RANDOM() < 0.25;

  #   INSERT INTO dd_graph_variables_holdout(variable_id)
  #   SELECT id FROM has_spouse WHERE sentence_id IN
  #   (SELECT * FROM holdout_sentence_ids);
  # """



}
